-- A lexical scanner generated by aflex
with text_io; use text_io;
with scanner_dfa; use scanner_dfa; 
with scanner_io; use scanner_io; 
--# line 1 "scanner.l"
------------------------------------------------------------------------------
--                                                                          --
--                            Matreshka Project                             --
--                                                                          --
--         Localization, Internationalization, Globalization for Ada        --
--                                                                          --
--                              Tools Component                             --
--                                                                          --
------------------------------------------------------------------------------
--                                                                          --
-- Copyright (C) 2011, Vadim Godunko <vgodunko@gmail.com>                   --
-- All rights reserved.                                                     --
--                                                                          --
-- Redistribution and use in source and binary forms, with or without       --
-- modification, are permitted provided that the following conditions       --
-- are met:                                                                 --
--                                                                          --
--  * Redistributions of source code must retain the above copyright        --
--    notice, this list of conditions and the following disclaimer.         --
--                                                                          --
--  * Redistributions in binary form must reproduce the above copyright     --
--    notice, this list of conditions and the following disclaimer in the   --
--    documentation and/or other materials provided with the distribution.  --
--                                                                          --
--  * Neither the name of the Vadim Godunko, IE nor the names of its        --
--    contributors may be used to endorse or promote products derived from  --
--    this software without specific prior written permission.              --
--                                                                          --
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS      --
-- "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT        --
-- LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    --
-- A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT     --
-- HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   --
-- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED --
-- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR   --
-- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF   --
-- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING     --
-- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS       --
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.             --
--                                                                          --
------------------------------------------------------------------------------
--  $Revision: 2402 $ $Date: 2012-01-07 01:30:36 +0200 ) $
------------------------------------------------------------------------------
--# line 55 "scanner.l"

with Parser_Tokens; use Parser_Tokens;
with Ada.Text_IO;
function YYLex return Token is
subtype short is integer range -32768..32767;
    yy_act : integer;
    yy_c : short;

-- returned upon end-of-file
YY_END_TOK : constant integer := 0;
YY_END_OF_BUFFER : constant := 18;
subtype yy_state_type is integer;
yy_current_state : yy_state_type;
INITIAL : constant := 0;
RULE : constant := 1;
SECT2 : constant := 2;
DEF : constant := 3;
NAMELIST : constant := 4;
yy_accept : constant array(0..108) of short :=
    (   0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       18,   17,    6,    6,   17,   17,    4,   16,   17,   13,
       12,   12,   12,   12,   12,    8,    7,   11,    9,   10,
        6,    1,    0,    2,    3,    4,   16,    0,    0,   15,
       12,   12,   12,   12,   12,    0,   12,   12,   12,   12,
       12,    0,   12,   12,   12,    8,    7,   11,   10,    1,
        0,    5,    0,    0,    0,   15,   12,    0,   12,   12,
       12,   12,    0,   14,   12,   12,   12,   12,   12,   12,
        0,    0,    0,    0,   12,   12,    0,   12,   12,   12,
       12,    0,   12,   12,   12,    0,    0,   12,    0,   12,

       12,   12,   12,   12,   12,    2,   12,    0
    ) ;

yy_ec : constant array(ASCII.NUL..ASCII.DEL) of short :=
    (   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    1,    5,    1,    1,    6,    1,    1,    1,
        1,    1,    1,    1,    7,    1,    1,    8,    8,    8,
        8,    8,    8,    8,    8,    8,    8,    1,    1,    1,
        1,    1,    1,    1,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,   10,    9,    9,    9,    9,   11,    9,    9,
       12,   13,   14,    1,    8,    1,   15,    9,    9,    9,

        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,   16,   10,   17,    9,    9,    9,   11,
        9,    9,   18,    1,   19,    1,    1
    ) ;

yy_meta : constant array(0..19) of short :=
    (   0,
        1,    2,    3,    2,    1,    1,    1,    4,    4,    4,
        4,    1,    1,    1,    4,    4,    4,    1,    1
    ) ;

yy_base : constant array(0..134) of short :=
    (   0,
        0,    7,   25,   42,  138,   59,   71,   74,   77,    0,
      140,  403,   26,  403,  132,   89,    0,   29,   29,  403,
       96,  108,  117,  129,   31,    0,   34,   37,  403,    0,
       38,    0,  135,  120,  403,    0,   43,   47,   48,  403,
      130,  142,  154,   45,    0,  130,    0,  167,  128,  180,
      114,  113,  192,   54,  120,    0,   52,   53,    0,    0,
      122,  403,  109,   64,   65,  114,    0,   45,    0,  114,
        0,  205,  114,  403,  217,  229,  111,  108,    0,   93,
       90,   77,   93,   84,    0,  242,   99,    0,  254,   87,
      267,  102,  280,   86,    0,   68,   92,    0,  292,    0,

       28,    0,    0,    0,    0,  403,    0,  403,  306,  310,
      314,    2,  318,  322,  326,  330,  334,    1,  338,  342,
      346,  350,  354,  358,  362,  366,  370,  374,  378,  382,
      386,  390,  394,  398
    ) ;

yy_def : constant array(0..134) of short :=
    (   0,
      109,  108,  109,  109,  109,  110,  111,  111,  109,    9,
      108,  108,  108,  108,  108,  108,  112,  108,  113,  108,
      114,  115,  114,  116,   23,  117,  108,  108,  108,  118,
      108,  119,  120,  108,  108,  112,  108,  113,  121,  108,
       23,  115,  116,   23,   42,  122,   42,  123,   42,  124,
       43,  125,  123,   43,   23,  117,  108,  108,  118,  119,
      120,  108,  108,  121,  121,  126,   53,  127,   53,   53,
       42,  124,  128,  108,  129,  130,   72,   23,   42,   43,
      108,  121,  126,  113,   53,  129,  131,   86,  132,   86,
      130,  133,  132,   91,   72,  108,  121,   93,  134,   93,

       93,   86,   72,   86,   91,  108,   93,    0,  108,  108,
      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
      108,  108,  108,  108
    ) ;

yy_nxt : constant array(0..422) of short :=
    (   0,
      108,   13,   14,   13,   59,   36,   15,   12,   13,   14,
       13,   12,   16,   15,   12,   17,   17,   17,   12,   12,
       12,   17,   17,   17,   12,   12,   18,   31,   18,   31,
       37,  107,   37,   39,   55,   57,   41,   57,   58,   31,
       58,   31,   19,   18,   37,   18,   37,   40,   55,   80,
       41,   39,   65,   57,   58,   57,   58,   80,   71,   19,
       12,   20,   12,   22,   23,   40,   66,   78,   65,   82,
       24,   25,   27,   12,   27,   27,   12,   27,   28,   29,
       28,   82,   66,   66,  106,   30,   30,   30,   97,  105,
      102,   30,   30,   30,   33,   66,   65,   84,   34,   35,

       42,   74,   40,   95,   74,   96,   78,   43,   44,   46,
       66,   46,   47,   41,   95,   95,   74,   85,   84,   48,
       49,   42,   50,   81,   62,   41,   55,   78,   43,   44,
       52,   71,   52,   53,   55,   41,   63,   62,   32,  108,
       20,   54,   41,   46,  108,   46,   47,  108,  108,  108,
      108,  108,  108,   48,   49,   52,  108,   52,   53,  108,
      108,  108,  108,  108,  108,  108,   54,   41,   68,  108,
       68,   69,  108,  108,  108,  108,  108,  108,  108,   70,
       45,   73,   74,   73,   75,  108,  108,  108,  108,  108,
      108,   76,   77,   68,  108,   68,   69,  108,  108,  108,

      108,  108,  108,  108,   70,   79,   73,   74,   73,   75,
      108,  108,  108,  108,  108,  108,   76,   77,   87,   74,
       87,   88,  108,  108,  108,  108,  108,  108,   89,   90,
       92,   74,   92,   93,  108,  108,  108,  108,  108,  108,
      108,   94,   72,   87,   74,   87,   88,  108,  108,  108,
      108,  108,  108,   89,   90,   99,   74,   99,  100,  108,
      108,  108,  108,  108,  108,  108,  101,   86,   92,   74,
       92,   93,  108,  108,  108,  108,  108,  108,  108,   94,
      103,   99,   74,   99,  100,  108,  108,  108,  108,  108,
      108,  108,  101,  104,   74,  108,  105,  108,  108,  108,

      108,  108,  108,  108,  108,  102,   12,   12,   12,   12,
       21,   21,   21,   21,   26,   26,   26,   26,   38,   38,
       38,   38,   41,  108,  108,   41,   45,   45,  108,   45,
       51,   51,  108,   51,   56,   56,  108,   56,   60,   60,
      108,   60,   61,   61,   61,   61,   64,   64,   64,   64,
       46,   46,  108,   46,   67,   67,  108,   67,   72,   72,
       72,   72,   52,   52,  108,   52,   83,   83,   83,   83,
       68,   68,  108,   68,   73,   73,   73,   73,   86,   86,
       86,   86,   91,   91,   91,   91,   87,   87,   87,   87,
       98,   98,   98,   98,   92,   92,   92,   92,   99,   99,

       99,   99,   11,  108,  108,  108,  108,  108,  108,  108,
      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
      108,  108
    ) ;

yy_chk : constant array(0..422) of short :=
    (   0,
        0,    1,    1,    1,  118,  112,    1,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    3,   13,    3,   13,
       18,  101,   18,   19,   25,   27,   25,   27,   28,   31,
       28,   31,    3,    4,   37,    4,   37,   19,   44,   68,
       44,   38,   39,   57,   58,   57,   58,   54,   68,    4,
        6,    6,    6,    6,    6,   38,   39,   54,   64,   65,
        6,    6,    7,    7,    7,    8,    8,    8,    9,    9,
        9,   82,   64,   65,   96,    9,    9,    9,   84,   94,
       90,    9,    9,    9,   16,   82,   97,   83,   16,   16,

       21,   87,   84,   87,   92,   81,   80,   21,   21,   22,
       97,   22,   22,   78,   77,   92,   73,   70,   66,   22,
       22,   23,   23,   63,   61,   55,   52,   51,   23,   23,
       24,   49,   24,   24,   46,   41,   34,   33,   15,   11,
        5,   24,   24,   42,    0,   42,   42,    0,    0,    0,
        0,    0,    0,   42,   42,   43,    0,   43,   43,    0,
        0,    0,    0,    0,    0,    0,   43,   43,   48,    0,
       48,   48,    0,    0,    0,    0,    0,    0,    0,   48,
       48,   50,   50,   50,   50,    0,    0,    0,    0,    0,
        0,   50,   50,   53,    0,   53,   53,    0,    0,    0,

        0,    0,    0,    0,   53,   53,   72,   72,   72,   72,
        0,    0,    0,    0,    0,    0,   72,   72,   75,   75,
       75,   75,    0,    0,    0,    0,    0,    0,   75,   75,
       76,   76,   76,   76,    0,    0,    0,    0,    0,    0,
        0,   76,   76,   86,   86,   86,   86,    0,    0,    0,
        0,    0,    0,   86,   86,   89,   89,   89,   89,    0,
        0,    0,    0,    0,    0,    0,   89,   89,   91,   91,
       91,   91,    0,    0,    0,    0,    0,    0,    0,   91,
       91,   93,   93,   93,   93,    0,    0,    0,    0,    0,
        0,    0,   93,   93,   99,    0,   99,    0,    0,    0,

        0,    0,    0,    0,    0,   99,  109,  109,  109,  109,
      110,  110,  110,  110,  111,  111,  111,  111,  113,  113,
      113,  113,  114,    0,    0,  114,  115,  115,    0,  115,
      116,  116,    0,  116,  117,  117,    0,  117,  119,  119,
        0,  119,  120,  120,  120,  120,  121,  121,  121,  121,
      122,  122,    0,  122,  123,  123,    0,  123,  124,  124,
      124,  124,  125,  125,    0,  125,  126,  126,  126,  126,
      127,  127,    0,  127,  128,  128,  128,  128,  129,  129,
      129,  129,  130,  130,  130,  130,  131,  131,  131,  131,
      132,  132,  132,  132,  133,  133,  133,  133,  134,  134,

      134,  134,  108,  108,  108,  108,  108,  108,  108,  108,
      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
      108,  108
    ) ;


-- copy whatever the last rule matched to the standard output

procedure ECHO is
begin
   if (text_io.is_open(user_output_file)) then
     text_io.put( user_output_file, yytext );
   else
     text_io.put( yytext );
   end if;
end ECHO;

-- enter a start condition.
-- Using procedure requires a () after the ENTER, but makes everything
-- much neater.

procedure ENTER( state : integer ) is
begin
     yy_start := 1 + 2 * state;
end ENTER;

-- action number for EOF rule of a given start state
function YY_STATE_EOF(state : integer) return integer is
begin
     return YY_END_OF_BUFFER + state + 1;
end YY_STATE_EOF;

-- return all but the first 'n' matched characters back to the input stream
procedure yyless(n : integer) is
begin
        yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
        yy_cp := yy_bp + n;
        yy_c_buf_p := yy_cp;
        YY_DO_BEFORE_ACTION; -- set up yytext again
end yyless;

-- redefine this if you have something you want each time.
procedure YY_USER_ACTION is
begin
        null;
end;

-- yy_get_previous_state - get the state just before the EOB char was reached

function yy_get_previous_state return yy_state_type is
    yy_current_state : yy_state_type;
    yy_c : short;
    yy_bp : integer := yytext_ptr;
begin
    yy_current_state := yy_start;
    if ( yy_ch_buf(yy_bp-1) = ASCII.LF ) then
	yy_current_state := yy_current_state + 1;
    end if;

    for yy_cp in yytext_ptr..yy_c_buf_p - 1 loop
	yy_c := yy_ec(yy_ch_buf(yy_cp));
	if ( yy_accept(yy_current_state) /= 0 ) then
	    yy_last_accepting_state := yy_current_state;
	    yy_last_accepting_cpos := yy_cp;
	end if;
	while ( yy_chk(yy_base(yy_current_state) + yy_c) /= yy_current_state ) loop
	    yy_current_state := yy_def(yy_current_state);
	    if ( yy_current_state >= 109 ) then
		yy_c := yy_meta(yy_c);
	    end if;
	end loop;
	yy_current_state := yy_nxt(yy_base(yy_current_state) + yy_c);
    end loop;

    return yy_current_state;
end yy_get_previous_state;

procedure yyrestart( input_file : file_type ) is
begin
   open_input(text_io.name(input_file));
end yyrestart;

begin -- of YYLex
<<new_file>>
        -- this is where we enter upon encountering an end-of-file and
        -- yywrap() indicating that we should continue processing

    if ( yy_init ) then
        if ( yy_start = 0 ) then
            yy_start := 1;      -- first start state
        end if;

        -- we put in the '\n' and start reading from [1] so that an
        -- initial match-at-newline will be true.

        yy_ch_buf(0) := ASCII.LF;
        yy_n_chars := 1;

        -- we always need two end-of-buffer characters.  The first causes
        -- a transition to the end-of-buffer state.  The second causes
        -- a jam in that state.

        yy_ch_buf(yy_n_chars) := YY_END_OF_BUFFER_CHAR;
        yy_ch_buf(yy_n_chars + 1) := YY_END_OF_BUFFER_CHAR;

        yy_eof_has_been_seen := false;

        yytext_ptr := 1;
        yy_c_buf_p := yytext_ptr;
        yy_hold_char := yy_ch_buf(yy_c_buf_p);
        yy_init := false;
    end if; -- yy_init

    loop                -- loops until end-of-file is reached


        yy_cp := yy_c_buf_p;

        -- support of yytext
        yy_ch_buf(yy_cp) := yy_hold_char;

        -- yy_bp points to the position in yy_ch_buf of the start of the
        -- current run.
	yy_bp := yy_cp;
	yy_current_state := yy_start;
	if ( yy_ch_buf(yy_bp-1) = ASCII.LF ) then
	    yy_current_state := yy_current_state + 1;
	end if;
	loop
		yy_c := yy_ec(yy_ch_buf(yy_cp));
		if ( yy_accept(yy_current_state) /= 0 ) then
		    yy_last_accepting_state := yy_current_state;
		    yy_last_accepting_cpos := yy_cp;
		end if;
		while ( yy_chk(yy_base(yy_current_state) + yy_c) /= yy_current_state ) loop
		    yy_current_state := yy_def(yy_current_state);
		    if ( yy_current_state >= 109 ) then
			yy_c := yy_meta(yy_c);
		    end if;
		end loop;
		yy_current_state := yy_nxt(yy_base(yy_current_state) + yy_c);
	    yy_cp := yy_cp + 1;
if ( yy_current_state = 108 ) then
    exit;
end if;
	end loop;
	yy_cp := yy_last_accepting_cpos;
	yy_current_state := yy_last_accepting_state;

<<next_action>>
	    yy_act := yy_accept(yy_current_state);
            YY_DO_BEFORE_ACTION;
            YY_USER_ACTION;

        if aflex_debug then  -- output acceptance info. for (-d) debug mode
            text_io.put( Standard_Error, "--accepting rule #" );
            text_io.put( Standard_Error, INTEGER'IMAGE(yy_act) );
            text_io.put_line( Standard_Error, "(""" & yytext & """)");
        end if;


<<do_action>>   -- this label is used only to access EOF actions
            case yy_act is
		when 0 => -- must backtrack
		-- undo the effects of YY_DO_BEFORE_ACTION
		yy_ch_buf(yy_cp) := yy_hold_char;
		yy_cp := yy_last_accepting_cpos;
		yy_current_state := yy_last_accepting_state;
		goto next_action;



when 1 => 
--# line 57 "scanner.l"
 null; 

when 2 => 
--# line 59 "scanner.l"

  Enter (NAMELIST);
  return Start;


when 3 => 
--# line 64 "scanner.l"

  Enter (NAMELIST);
  return Excl_Start;


when 4 => 
--# line 69 "scanner.l"

   Enter (DEF);
   return Name;


when 5 => 
--# line 74 "scanner.l"

  Enter (SECT2);
  return Section_End; 


when 6 => 
--# line 79 "scanner.l"
null;

when 7 => 
--# line 81 "scanner.l"
 null; 

when 8 => 
--# line 83 "scanner.l"

   Enter (INITIAL);
   return Regexp;


when 9 => 
--# line 88 "scanner.l"

  Enter (INITIAL);
  return Name_List_End;


when 10 => 
--# line 93 "scanner.l"

  return Name;


when 11 => 
--# line 97 "scanner.l"
 null; 

when 12 => 
--# line 99 "scanner.l"

   Enter (RULE);
   return Regexp;


when 13 => 
--# line 104 "scanner.l"
 null; 

when 14 => 
--# line 106 "scanner.l"

  Enter (INITIAL);
  return Section_End; 


when 15 => 
--# line 111 "scanner.l"

   Enter (SECT2);
   return Action;


when 16 => 
--# line 116 "scanner.l"
 null; 

--^[a-zA-Z]+  {ENTER (DEF); return Name;}
--<DEF>[\t ]+ {}
--<DEF>.+     {Enter (INITIAL); return Definition;}
--<DEF>\n     {return Error;}
when 17 => 
--# line 122 "scanner.l"
ECHO;
when YY_END_OF_BUFFER + INITIAL + 1 |
YY_END_OF_BUFFER + RULE + 1 |
YY_END_OF_BUFFER + SECT2 + 1 |
YY_END_OF_BUFFER + DEF + 1 |
YY_END_OF_BUFFER + NAMELIST + 1 => 
    return End_Of_Input;
                when YY_END_OF_BUFFER =>
                    -- undo the effects of YY_DO_BEFORE_ACTION
                    yy_ch_buf(yy_cp) := yy_hold_char;

                    yytext_ptr := yy_bp;

                    case yy_get_next_buffer is
                        when EOB_ACT_END_OF_FILE =>
                            begin
                            if ( yywrap ) then
                                -- note: because we've taken care in
                                -- yy_get_next_buffer() to have set up yytext,
                                -- we can now set up yy_c_buf_p so that if some
                                -- total hoser (like aflex itself) wants
                                -- to call the scanner after we return the
                                -- End_Of_Input, it'll still work - another
                                -- End_Of_Input will get returned.

                                yy_c_buf_p := yytext_ptr;

                                yy_act := YY_STATE_EOF((yy_start - 1) / 2);

                                goto do_action;
                            else
                                --  start processing a new file
                                yy_init := true;
                                goto new_file;
                            end if;
                            end;
                        when EOB_ACT_RESTART_SCAN =>
                            yy_c_buf_p := yytext_ptr;
                            yy_hold_char := yy_ch_buf(yy_c_buf_p);
                        when EOB_ACT_LAST_MATCH =>
                            yy_c_buf_p := yy_n_chars;
                            yy_current_state := yy_get_previous_state;

                            yy_cp := yy_c_buf_p;
                            yy_bp := yytext_ptr;
                            goto next_action;
                        when others => null;
                        end case; -- case yy_get_next_buffer()
                when others =>
                    text_io.put( "action # " );
                    text_io.put( INTEGER'IMAGE(yy_act) );
                    text_io.new_line;
                    raise AFLEX_INTERNAL_ERROR;
            end case; -- case (yy_act)
        end loop; -- end of loop waiting for end of file
end YYLex;
--# line 122 "scanner.l"
