with Ada.Characters.Wide_Wide_Latin_1;

with Scanner.Tables;
with Matreshka.Internals.Unicode;

package body Scanner is

   use Ada.Characters.Wide_Wide_Latin_1;
   use Parser.Tokens;
   use Matreshka.Internals.Unicode;
   use Matreshka.Internals.Utf16;
   use Scanner.Tables;

   procedure Enter_Start_Condition (State : Integer);
   --  Enter a start condition.

   function YY_EOF_State return Integer;
   --  Action number for EOF rule of a current start state

   ---------------------------
   -- Enter_Start_Condition --
   ---------------------------

   procedure Enter_Start_Condition (State : Integer) is
   begin
      YY_Start_State := 1 + 2 * State;
   end Enter_Start_Condition;

   ------------------
   -- YY_EOF_State --
   ------------------

   function YY_EOF_State return Integer is
   begin
     return YY_END_OF_BUFFER + (YY_Start_State - 1) / 2 + 1;
   end YY_EOF_State;

   -----------
   -- YYLex --
   -----------

   function YYLex return Parser.Tokens.Token is
      YY_Action                  : Integer;
      YY_Back_Position           : Utf16_String_Index;
      YY_Next_Position           : Utf16_String_Index;
      --  Position of the next character in the source string.
      YY_Current_State           : Integer;
      YY_Current_Code            : Code_Point;
      YY_C                       : Integer;
      YY_Last_Accepting_State    : Integer;
      YY_Last_Accepting_Position : Utf16_String_Index;

      function YYText return Wide_Wide_String;
      --  XXX Dummy function to support transition

      ------------
      -- YYText --
      ------------

      function YYText return Wide_Wide_String is
         Length : constant Natural :=
           Natural (YY_Current_Position - YY_Back_Position);
         Result : Wide_Wide_String (1 .. Length);
         Last   : Natural := 0;
         Index  : Utf16_String_Index := YY_Back_Position;
         Code   : Code_Point;

      begin
         while Index < YY_Current_Position loop
            Unchecked_Next (Data.Value, Index, Code);
            Last := Last + 1;
            Result (Last) := Wide_Wide_Character'Val (Code);
         end loop;

         return Result (1 .. Last); 
      end YYText;

   begin
      loop  --  Loops until end-of-string is reached
         YY_Back_Position := YY_Current_Position;
         YY_Current_State := YY_Start_State;

         loop
            YY_Next_Position := YY_Current_Position;

            if YY_Next_Position = Data.Unused then
               --  By convention, aflex always assign zero equivalence class
               --  to the end-of-buffer state.

               YY_C := 0;

            else
               Unchecked_Next (Data.Value, YY_Next_Position, YY_Current_Code);
               YY_C :=
                 YY_EC_Base
                  (YY_Current_Code / 16#100#) (YY_Current_Code mod 16#100#);
            end if;

            if YY_Accept (YY_Current_State) /= 0 then
               --  Accepting state reached, save if to backtrack

               YY_Last_Accepting_State    := YY_Current_State;
               YY_Last_Accepting_Position := YY_Current_Position;
            end if;

            while YY_Chk (YY_Base (YY_Current_State) + YY_C)
                    /= YY_Current_State
            loop
               YY_Current_State := YY_Def (YY_Current_State);

               if YY_Current_State >= YY_First_Template then
                  YY_C := YY_Meta (YY_C);
               end if;
            end loop;

            YY_Current_State := YY_Nxt (YY_Base (YY_Current_State) + YY_C);
            YY_Current_Position := YY_Next_Position;

            exit when YY_Current_State = YY_Jam_State;
         end loop;

         --  Return back to last accepting state.

         YY_Current_Position := YY_Last_Accepting_Position;
         YY_Current_State    := YY_Last_Accepting_State;

         --  Retrieve associated action and execute it.

         YY_Action := YY_Accept (YY_Current_State);

<<Do_Action>>  --  This label is used only to access EOF actions
         case YY_Action is
            when 0 =>
               --  Backtrack

               YY_Current_Position := YY_Last_Accepting_Position;
               YY_Current_State    := YY_Last_Accepting_State;
%%

            when YY_END_OF_BUFFER =>
               YY_Action := YY_EOF_State;

               goto Do_Action;

            when others =>
               raise Program_Error;
         end case;
      end loop; -- end of loop waiting for end of file
   end YYLex;

end Scanner;
