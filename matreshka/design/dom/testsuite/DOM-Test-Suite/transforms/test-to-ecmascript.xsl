<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
Copyright &#xA9; 2001-2005 World Wide Web Consortium,
(Massachusetts Institute of Technology, European Research Consortium 
for Informatics and Mathematics, Keio University). All 
Rights Reserved. This work is distributed under the W3C&#xAE; Software License [1] in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even 
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 

[1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231
-->

<!--   
This transform generates ECMAScript source code from a language independent
test representation.

This transform requires an auxiliary file "interfaces.xml" that 
is produced by applying "extract.xsl" to the appropriate DOM
specificiation.


Usage:

saxon -o someTest.js someTest.xml test-to-ecmascript.xsl


-->



<xsl:stylesheet version="1.0" 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<!--  relative to transform   -->
	<xsl:param name="interfaces-docname">..\build\dom1-interfaces.xml</xsl:param>
    <xsl:param name="target-uri-base"/>


<xsl:output method="text" encoding="UTF-8"/>
<xsl:variable name="domspec" select="document($interfaces-docname)"/>

<xsl:template match="/">
	<xsl:apply-templates/>
</xsl:template>

<!-- 
       Copy any comments from the source file that have
       a copyright notice  

-->
<xsl:template match="comment()[contains(.,'Copyright')]">
/*
This ECMAScript source file was generated by test-to-java.xsl
and is a derived work from the source document.
The source document contained the following notice:

<xsl:value-of select="."/>
*/
</xsl:template>


<!--   produces JavaDoc for metadata elements   -->
<xsl:template match="*[local-name() = 'metadata']">
/**
* <xsl:value-of select="*[local-name()='description']"/><xsl:text>
</xsl:text>

<xsl:for-each select="*[local-name()='creator']">
<xsl:text>* @author </xsl:text><xsl:value-of select="."/><xsl:text>
</xsl:text>
</xsl:for-each>

<xsl:for-each select="*[local-name()='contributor']">
<xsl:text>* @author </xsl:text><xsl:value-of select="."/><xsl:text>
</xsl:text>
</xsl:for-each>

<xsl:for-each select="*[local-name()='subject']">
	<xsl:text>* @see </xsl:text>
	<xsl:value-of select="@resource"/>
	<xsl:text>
</xsl:text>
</xsl:for-each>

<xsl:for-each select="*[local-name()='source']">
	<xsl:text>* @see </xsl:text>
	<xsl:value-of select="@resource"/>
	<xsl:text>
</xsl:text>
</xsl:for-each>
<xsl:text>*/
</xsl:text>
</xsl:template>




<!--   when encountering a test   -->
<xsl:template match="*[local-name()='test']">

	<xsl:if test="*[local-name() = 'var' and @type='EventMonitor' and @name='monitor']">
		<xsl:text>//EventMonitor's require a document level variable named monitor
var monitor;
	 </xsl:text>
	 </xsl:if>
	<xsl:if test="*[local-name() = 'var' and @type='DOMErrorMonitor' and @name='errorMonitor']">
		<xsl:text>//DOMErrorMonitor's require a document level variable named errorMonitor
var errorMonitor;
	 </xsl:text>
	 </xsl:if>
	<xsl:if test="*[local-name() = 'var' and @type='UserDataMonitor' and @name='userDataMonitor']">
		<xsl:text>//UserDataMonitor's require a document level variable named userDataMonitor
var userDataMonitor;
	 </xsl:text>
	 </xsl:if>

	<!--   create anonymous inner classes  -->	
<xsl:apply-templates mode="innerClass" select="*[local-name() = 'var'  and *[local-name() != 'member']]"/>
	

<!--  if there is a metadata child element then
          produce documentation comments    -->
    <xsl:apply-templates select="*[local-name()='metadata']"/>

   <xsl:text>function </xsl:text>
   <xsl:value-of select="@name"/>
   <xsl:text>() {
   var success;
    if(checkInitialization(builder, "</xsl:text><xsl:value-of select="@name"/><xsl:text>") != null) return;
    </xsl:text>
<xsl:apply-templates mode="body"/>
    <xsl:text>
}

</xsl:text>
</xsl:template>


<!--   when encountering a test   -->
<xsl:template match="*[local-name()='suite']">

<!--  if there is a metadata child element then
          produce documentation comments    -->
    <xsl:apply-templates select="*[local-name()='metadata']"/>

    <xsl:text>
    function getURL(sourceURL)
    {
	    var URL = location.href;
        if (URL.indexOf('?') != -1)
        {
            URL = URL.substring(0, URL.indexOf('?'));
        }
        URL = URL.substring(0, URL.lastIndexOf("/") + 1) + sourceURL;

        return URL;
    }
    
    function suite() {
        var newsuite = new top.jsUnitTestSuite();       
</xsl:text>
    <xsl:for-each select="*[local-name() = 'suite.member']">
        <xsl:text>        newsuite.addTestPage(getURL("</xsl:text>
        <xsl:value-of select="substring-before(@href,'.xml')"/>
        <xsl:text>.html"));
</xsl:text>
    </xsl:for-each>

    return newsuite;
}
</xsl:template>



<!--    
    The following templates generate the body of the test function   
    
-->

<!--

    Implementation conditions and metadata elements produce nothing
	in the body of the test method

-->
<xsl:template match="*[local-name()='metadata']" mode="body"/>
<xsl:template match="*[local-name()='validating']" mode="body"/>
<xsl:template match="*[local-name()='coalescing']" mode="body"/>
<xsl:template match="*[local-name()='expandEntityReferences']" mode="body"/>
<xsl:template match="*[local-name()='ignoringElementContentWhitespace']" mode="body"/>
<xsl:template match="*[local-name()='ignoringComments']" mode="body"/>
<xsl:template match="*[local-name()='namespaceAware']" mode="body"/>
<xsl:template match="*[local-name()='signed']" mode="body"/>
<xsl:template match="*[local-name()='not']" mode="body"/>

<!--   this template generates code for the DOMString.length  -->
<xsl:template match="*[local-name()='length' and @interface='DOMString']" mode="body">
    <xsl:value-of select="@var"/>
    <xsl:text> = </xsl:text>
    <xsl:value-of select="@obj"/>
    <xsl:text>.length;
      </xsl:text>
</xsl:template>


<!--   implementation attribute doesn't do anything in the body of the test  -->
<xsl:template match="*[local-name()='implementationAttribute']" mode="body"/>

<xsl:template match="*[local-name()='DOMImplementationRegistry.newInstance']" mode="body">
     <xsl:value-of select="@var"/>
     <xsl:text> = DOMImplementationRegistry;
      </xsl:text>
</xsl:template>


<!--  
     hasFeature is a little unusual as both an implementation
	 condition and a DOM function.  This template should only
	 produce code when used as a DOM function.
-->
<xsl:template match="*[local-name()='hasFeature']" mode="body">
	<!--  if it doesn't have a var then 
			it is part of the implementation conditions and
			should not be produced in the body of the function  -->
	<xsl:if test="@var">
		<xsl:value-of select="@var"/>
		<xsl:text> = </xsl:text>
		<!--  use @obj if provided, otherwise _framework   -->
		<xsl:if test="@obj">
			<xsl:value-of select="@obj"/>
			<xsl:text>.</xsl:text>
		</xsl:if>
		<xsl:text>hasFeature(</xsl:text>
		<xsl:value-of select="@feature"/>
		<xsl:text>,</xsl:text>
		<xsl:choose>
			<xsl:when test="@version">
				<xsl:value-of select="@version"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>null</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>);
</xsl:text>
	</xsl:if>
</xsl:template>


<xsl:template match="*[local-name()='DOMImplementationRegistry.newInstance']" mode="body">
        <xsl:value-of select="@var"/>
        <xsl:text> = DOMImplementationRegistry;
         </xsl:text>
</xsl:template>


<xsl:template match="*[starts-with(local-name(),'getDOMImplementation')]" mode="body">
        <xsl:value-of select="@var"/>
        <xsl:text> = </xsl:text>
        <xsl:value-of select="@obj"/>
        <xsl:text>.</xsl:text>
        <xsl:value-of select="local-name()"/>
        <xsl:text>(</xsl:text>
        <xsl:value-of select="@features"/>
        <xsl:text>);
         </xsl:text>
</xsl:template>

<!--    

	test framework constructs

-->
<xsl:template match="*[local-name()= 'var']" mode="body">
	<xsl:variable name="varname" select="@name"/>
	<xsl:choose>
		<!-- EventMonitors, anon inner classes have document scope   -->
		<xsl:when test="@type = 'EventMonitor'"/>
		<xsl:when test="@type = 'UserDataMonitor'"/>
		<xsl:when test="@type = 'DOMErrorMonitor'"/>
		<xsl:when test="*"/>
		<xsl:otherwise>
			<xsl:text>var </xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:value-of select="$varname"/>
	<xsl:choose>
                <xsl:when test="@isNull='true'">
                  <xsl:text> = null;
</xsl:text>
                </xsl:when>
		<!--  explicit value, just add it  -->
		<xsl:when test="@value"> = <xsl:apply-templates select="@value"/>;</xsl:when>
		<!--  member, allocate collection or list and populate it  -->
		<xsl:when test="@type='List' or @type='Collection'">
			<xsl:text> = new Array();
</xsl:text>
			<xsl:for-each select="*[local-name()='member']">
                <xsl:text>      </xsl:text>
     			<xsl:value-of select="$varname"/>
                <xsl:text>[</xsl:text>
                <xsl:value-of select="position()-1"/>
                <xsl:text>] = </xsl:text>
                <xsl:value-of select="text()"/>
                <xsl:text>;
</xsl:text>
			</xsl:for-each>
		</xsl:when>
		
        <!--  event monitor type implies constructor    -->
        <xsl:when test="@type='EventMonitor'">
        	<xsl:choose>
        		<xsl:when test="@name != 'monitor'">
        			<xsl:message>EventMonitors must be named monitor</xsl:message>
        			<xsl:text>; fail("EventMonitors must be named monitor");
      </xsl:text>
        		</xsl:when>
        		<xsl:otherwise>
            		<xsl:text> = new EventMonitor();
      </xsl:text>
      			</xsl:otherwise>
      		</xsl:choose>
        </xsl:when>


        <!--  error monitor type implies constructor    -->
        <xsl:when test="@type='DOMErrorMonitor'">
        	<xsl:choose>
        		<xsl:when test="@name != 'errorMonitor'">
        			<xsl:message>DOMErrorMonitors must be named errorMonitor</xsl:message>
        			<xsl:text>; fail("DOMErrorMonitors must be named errorMonitor");
      </xsl:text>
        		</xsl:when>
        		<xsl:otherwise>
            		<xsl:text> = new DOMErrorMonitor();
      </xsl:text>
      			</xsl:otherwise>
      		</xsl:choose>
        </xsl:when>


        <!--  error monitor type implies constructor    -->
        <xsl:when test="@type='UserDataMonitor'">
        	<xsl:choose>
        		<xsl:when test="@name != 'userDataMonitor'">
        			<xsl:message>UserDataMonitors must be named userDataMonitor</xsl:message>
        			<xsl:text>; fail("UserDataMonitors must be named userDataMonitor");
      </xsl:text>
        		</xsl:when>
        		<xsl:otherwise>
            		<xsl:text> = new UserDataMonitor();
      </xsl:text>
      			</xsl:otherwise>
      		</xsl:choose>
        </xsl:when>
		
		<!--  virtual method indicates anonymous inner class, 
		       which the ECMAScript does as an external class  -->
		<xsl:when test="*">
			<xsl:text> = new </xsl:text>
			<xsl:value-of select="concat(@type, generate-id(.))"/>
			<xsl:text>(</xsl:text>
				<xsl:for-each select="*[local-name() = 'var' and @value]">
					<xsl:if test="position() &gt; 1">, </xsl:if>
					<xsl:value-of select="@value"/>
				</xsl:for-each>
			<xsl:text>);
	  </xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>;</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
      </xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='addEventListener' or local-name() = 'removeEventListener']" mode="body">
	<xsl:value-of select="@obj"/>
	<xsl:value-of select="concat('.', concat(local-name(), '('))"/>
	<xsl:value-of select="@type"/>
	<xsl:text>, </xsl:text>
	<xsl:value-of select="@listener"/>
	<xsl:text>.handleEvent, </xsl:text>
	<xsl:value-of select="@useCapture"/>
	<xsl:text>);
	 </xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='setParameter']" mode="body">
    <xsl:param name="vardefs"/>
	<xsl:value-of select="@obj"/>
	<xsl:text>.setParameter(</xsl:text>
	<xsl:value-of select="@name"/>
	<xsl:text>, </xsl:text>
	<xsl:variable name="paramValue" select="@value"/>
	<!-- xsl:variable name="paramType" select="$vardefs[@name = $paramValue]/@type"/ -->
	<xsl:variable name="paramType" select="preceding::*[local-name() = 'var' and @name = $paramValue]/@type"/>
	<xsl:value-of select="@value"/>
	<xsl:choose>
		<xsl:when test="$paramType = 'DOMErrorHandler' or $paramType = 'DOMErrorMonitor'">
			<xsl:text>.handleError</xsl:text>
		</xsl:when>
		<xsl:when test="$paramType = 'ResourceResolver'">
			<xsl:text>.resolveResource</xsl:text>
		</xsl:when>
	</xsl:choose>
	<xsl:text>);
	 </xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='setUserData']" mode="body">
    <xsl:param name="vardefs"/>
    <xsl:text>if (null == </xsl:text>
    <xsl:value-of select="@handler"/>
    <xsl:text>) {
         </xsl:text>
         <xsl:value-of select="@obj"/>
         <xsl:text>.setUserData(</xsl:text>
         <xsl:value-of select="@key"/>
         <xsl:text>, </xsl:text>
         <xsl:value-of select="@data"/>
         <xsl:text>, null);
      } else {
          </xsl:text>
         <xsl:value-of select="@obj"/>
         <xsl:text>.setUserData(</xsl:text>
         <xsl:value-of select="@key"/>
         <xsl:text>, </xsl:text>
         <xsl:value-of select="@data"/>
         <xsl:text>, </xsl:text>
         <xsl:value-of select="@handler"/>
         <xsl:text>.handle);
      }
       </xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='comment']" mode="body">
	<xsl:text>/* </xsl:text>
	<xsl:value-of select="."/>
	<xsl:text> */
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='wait']" mode="body">
	<xsl:text>wait(</xsl:text>
	<xsl:value-of select="@milliseconds"/>
	<xsl:text>);
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='append']" mode="body">
	<xsl:value-of select="@collection"/>
	<xsl:text>[</xsl:text>
    <xsl:value-of select="@collection"/>
    <xsl:text>.length] = </xsl:text>
	<xsl:value-of select="@item"/>
    <xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='assign']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:choose>
		<xsl:when test="substring(@value,1,1) = '&quot;' or string(number(@value)) != 'NaN'">
			<xsl:value-of select="@value"/>
			<xsl:text>;
</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:variable name="var" select="@var"/>
			<xsl:variable name="value" select="@value"/>
			<xsl:call-template name="retval-cast">
				<xsl:with-param name="variable" select="@var"/>
				<xsl:with-param name="vartype" select="ancestor::*[local-name()='test']/*[local-name() = 'var' and @name = $var]/@type"/>
				<xsl:with-param name="rettype" select="ancestor::*[local-name()='test']/*[local-name() = 'var' and @name = $value]/@type"/>
			</xsl:call-template>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@value"/>
			<xsl:text>;
</xsl:text>
		</xsl:otherwise>
	</xsl:choose>	
</xsl:template>

<xsl:template match="*[local-name()='return']" mode="body">
    <xsl:param name="vardefs"/>
    <xsl:text>        return </xsl:text>
    <xsl:value-of select="@value"/>
    <xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='increment']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> += </xsl:text>
	<xsl:value-of select="@value"/>
	<xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='decrement']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> -= </xsl:text>
	<xsl:value-of select="@value"/>
	<xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='plus']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> + </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='subtract']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> - </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='mult']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> * </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='divide']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:value-of select="@op1"/>
	<xsl:text> / </xsl:text>
	<xsl:value-of select="@op2"/>
	<xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='implementation']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = </xsl:text>
	<xsl:choose>
		<xsl:when test="@obj">
			<xsl:value-of select="@obj"/>
			<xsl:text>.implementation;
</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>getImplementation();
</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template match="*[local-name()='createXPathEvaluator']" mode="body">
	<xsl:value-of select="@var"/>
	<xsl:text> = createXPathEvaluator(</xsl:text>
    <xsl:value-of select="@document"/>
    <xsl:text>);
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='fail']" mode="body">
    <xsl:param name="vardefs"/>
    <xsl:text>fail("</xsl:text>
    <xsl:value-of select="@id"/>
    <xsl:text>");
     </xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='assertTrue']" mode="body">
	<xsl:param name="type"/>
	<xsl:choose>
		<xsl:when test="@actual">
			<xsl:text>assertTrue("</xsl:text>
			<xsl:value-of select="@id"/>
			<xsl:text>",</xsl:text>
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>if(</xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>) {
</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>}
</xsl:text>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise>
            <xsl:text>	assertTrue("</xsl:text>
		    <xsl:value-of select="@id"/>
		    <xsl:text>",
      </xsl:text>
		    <xsl:apply-templates select="*[1]" mode="condition"/>
		    <xsl:text>);
</xsl:text>
	        <xsl:if test="count(*) &gt; 1">
                <xsl:text>
   if(</xsl:text>
                <xsl:apply-templates select="*[1]" mode="condition"/>
                <xsl:text>) {
</xsl:text>
		        <xsl:apply-templates select="*[position() &gt; 1]" mode="body"/>
                <xsl:text>
	}
</xsl:text>
            </xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template match="*[local-name()='assertFalse']" mode="body">
	<xsl:param name="type"/>
	<xsl:choose>
		<xsl:when test="@actual">
			<xsl:text>assertFalse("</xsl:text>
			<xsl:value-of select="@id"/>
			<xsl:text>",</xsl:text>
			<xsl:value-of select="@actual"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="*">
				<xsl:text>if(!</xsl:text>
				<xsl:value-of select="@actual"/>
				<xsl:text>) {</xsl:text>
				<xsl:apply-templates mode="body"/>
				<xsl:text>}
</xsl:text>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise>
			{
			<xsl:text>assertFalse("</xsl:text>
			<xsl:value-of select="@id"/>
			<xsl:text>",</xsl:text>
			<xsl:apply-templates select="*[1]" mode="condition"/>
			<xsl:text>);
</xsl:text>
			<xsl:if test="count(*) &gt; 1">
    if(!<xsl:apply-templates select="*[1]" mode="condition"/>) {
<xsl:apply-templates mode="body"/>
    }
</xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template match="*[local-name()='assertNull']" mode="body">
	<xsl:text>assertNull("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",</xsl:text>
	<xsl:value-of select="@actual"/>
	<xsl:text>);
    </xsl:text>
	<xsl:if test="*">
		<xsl:text>if(</xsl:text>
		<xsl:value-of select="@actual"/>
		<xsl:text> == null) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
    </xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertNotNull']" mode="body">
	<xsl:text>assertNotNull("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",</xsl:text>
	<xsl:value-of select="@actual"/>
	<xsl:text>);
</xsl:text>
	<xsl:if test="*">
		<xsl:text>if(</xsl:text>
		<xsl:value-of select="@actual"/>
		<xsl:text> != null) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertSame']" mode="body">
	<xsl:text>assertSame("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",</xsl:text>
	<xsl:value-of select="@expected"/>
	<xsl:text>,</xsl:text>
	<xsl:value-of select="@actual"/>
	<xsl:text>);
</xsl:text>
	<xsl:if test="count(*) &gt; 0">
		<xsl:text>if(same(</xsl:text>
		<xsl:value-of select="@expected"/>
		<xsl:text>,</xsl:text>
		<xsl:value-of select="@actual"/>
		<xsl:text>)) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertInstanceOf']" mode="body">
	<xsl:text>assertInstanceOf("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>","</xsl:text>
    <xsl:value-of select="@type"/>
	<xsl:text>",</xsl:text>
	<xsl:value-of select="@obj"/>
	<xsl:text>);
</xsl:text>
	<xsl:if test="*">
		<xsl:text>if(</xsl:text>
		<xsl:value-of select="@obj"/>
		<xsl:text> instanceof </xsl:text>
		<xsl:call-template name="produce-type">
			<xsl:with-param name="type" select="@type"/>
		</xsl:call-template>
		<xsl:text>) {</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertSize']" mode="body">
    <xsl:text>assertSize("</xsl:text>
    <xsl:value-of select="@id"/>
    <xsl:text>",</xsl:text>
	<xsl:value-of select="@size"/>
	<xsl:text>,</xsl:text>
	<xsl:value-of select="@collection"/>
	<xsl:text>);
</xsl:text>
    <xsl:if test="*">
   if(size(<xsl:value-of select="@collection"/>) == <xsl:value-of select="@size"/>) {
<xsl:apply-templates mode="body"/>
<xsl:text>
   }
      </xsl:text>
</xsl:if>
</xsl:template>

<xsl:template match="*[local-name()='assertURIEquals']" mode="body">
    <xsl:text>assertURIEquals("</xsl:text>
    <xsl:value-of select="@id"/>
    <xsl:text>",</xsl:text>
    <xsl:choose>
        <xsl:when test="@scheme"><xsl:value-of select="@scheme"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@path"><xsl:value-of select="@path"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@host"><xsl:value-of select="@host"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@file"><xsl:value-of select="@file"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@name"><xsl:value-of select="@name"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@query"><xsl:value-of select="@query"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@fragment"><xsl:value-of select="@fragment"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
        <xsl:when test="@isAbsolute"><xsl:value-of select="@isAbsolute"/>,</xsl:when>
        <xsl:otherwise>null,</xsl:otherwise>
    </xsl:choose>
    <xsl:value-of select="@actual"/>
	<xsl:text>);
</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='assertEquals']" mode="body">
    <xsl:variable name="expected" select="@expected"/>
    <xsl:variable name="expectedType" select="ancestor::*[local-name() = 'test']/*[local-name() = 'var'  and @name = $expected]/@type"/>
    <xsl:text>assertEquals</xsl:text>
    <xsl:choose>
        <xsl:when test="$expectedType = 'Collection'">Collection</xsl:when>
        <xsl:when test="$expectedType = 'List'">List</xsl:when>
    </xsl:choose>
    <xsl:choose>
    	<xsl:when test="@ignoreCase='auto'">
    		<xsl:text>AutoCase("</xsl:text>
    		<xsl:choose>
    			<xsl:when test="@context">
    				<xsl:value-of select="@context"/>
    			</xsl:when>
    			<xsl:otherwise>
    				<xsl:text>element</xsl:text>
    			</xsl:otherwise>
    		</xsl:choose>
    		<xsl:text>", "</xsl:text>
    	</xsl:when>
    	<xsl:otherwise>
    		<xsl:text>("</xsl:text>
    	</xsl:otherwise>
    </xsl:choose>
    <xsl:value-of select="@id"/>
    <xsl:text>",</xsl:text>
    <xsl:choose>
        <xsl:when test="@ignoreCase='true'">
            <xsl:choose>
                <xsl:when test="$expectedType = 'Collection' or $expectedType = 'List'">
                    <xsl:text>toLowerArray(</xsl:text>
                    <xsl:value-of select="@expected"/>
                    <xsl:text>),toLowerArray(</xsl:text>
                    <xsl:value-of select="@actual"/>
		    <xsl:text>));
       </xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="@expected"/>
                    <xsl:text>.toLowerCase(),</xsl:text>
                    <xsl:value-of select="@actual"/>
                    <xsl:text>.toLowerCase());
       </xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:when>

        <xsl:otherwise>
            <xsl:value-of select="@expected"/>
            <xsl:text>,</xsl:text>
            <xsl:value-of select="@actual"/>
            <xsl:text>);
       </xsl:text>
        </xsl:otherwise>
    </xsl:choose>
</xsl:template>



<xsl:template match="*[local-name()='assertNotEquals']" mode="body">
    <xsl:text>assert("</xsl:text>
    <xsl:value-of select="@id"/>
    <xsl:text>",</xsl:text>
    <xsl:value-of select="@expected"/>
    <xsl:text> != </xsl:text>
    <xsl:value-of select="@actual"/>
    <xsl:text>);
      </xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='assertEventCount']" mode="body">
	<xsl:text>{
	var _tmpBool = true;
</xsl:text>
	<xsl:if test="@atCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getAtCount() == </xsl:text>
		<xsl:value-of select="@atCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:if test="@captureCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getCaptureCount() == </xsl:text>
		<xsl:value-of select="@captureCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:if test="@bubbleCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getBubbleCount() == </xsl:text>
		<xsl:value-of select="@BubbleCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:if test="@totalCount">
		<xsl:text>_tmpBool &amp;= (</xsl:text>
		<xsl:value-of select="@monitor"/>
		<xsl:text>.getTotalCount() == </xsl:text>
		<xsl:value-of select="@totalCount"/>
		<xsl:text>);
</xsl:text>
	</xsl:if>
	<xsl:text>assertTrue("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",_tmpBool);
</xsl:text>
	<xsl:if test="*">
		<xsl:text>if(_tmpBool) {
</xsl:text>
		<xsl:apply-templates mode="body"/>
		<xsl:text>}
</xsl:text>
	</xsl:if>
	<xsl:text>}</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='if']" mode="body">
	if(
	<xsl:apply-templates select="*[1]" mode="condition"/>
	) {
	<xsl:apply-templates select="*[position() &gt; 1 and local-name() != 'else']" mode="body"/>
	}
	<xsl:for-each select="*[local-name()='else']">
		else {
			<xsl:apply-templates mode="body"/>
		}
	</xsl:for-each>
</xsl:template>

<xsl:template match="*[local-name()='while']" mode="body">
    while(
	<xsl:apply-templates select="*[1]" mode="condition"/>
	) {
	<xsl:apply-templates select="*[position() &gt; 1]" mode="body"/>
	}
</xsl:template>

<xsl:template match="*[local-name()='for-each']" mode="body">
    <xsl:variable name="indexvar" select="concat('index', generate-id(.))"/>
    <xsl:text>for(var </xsl:text>
    <xsl:value-of select="$indexvar"/>
    <xsl:text> = 0;</xsl:text>
    <xsl:value-of select="$indexvar"/>
    <xsl:text> &lt; </xsl:text>
	<xsl:variable name="varname" select="@collection"/>
	<xsl:value-of select="@collection"/>
	<xsl:text>.length; </xsl:text>
	<xsl:value-of select="$indexvar"/><xsl:text>++) {
      </xsl:text>
	<xsl:value-of select="@member"/>
	<xsl:text> = </xsl:text>
    <xsl:value-of select="@collection"/>
    <xsl:variable name="collType" select="ancestor::*[local-name() = 'test']/*[local-name() = 'var' and @name=$varname]/@type"/>
    <xsl:choose>
        <xsl:when test="$collType = 'List' or $collType='Collection'">
            <xsl:text>[</xsl:text><xsl:value-of select="$indexvar"/><xsl:text>];
      </xsl:text>
        </xsl:when>
        <xsl:otherwise>
            <xsl:text>.item(</xsl:text><xsl:value-of select="$indexvar"/><xsl:text>);
      </xsl:text>
        </xsl:otherwise>
    </xsl:choose>
	<xsl:apply-templates select="*" mode="body"/>
<xsl:text>
	}
   </xsl:text>
</xsl:template>



<xsl:template match="*[local-name()='atEvents']" mode="body">
    <xsl:value-of select="@var"/> = <xsl:value-of select="@obj"/>.atEvents;
</xsl:template>


<xsl:template match="*[local-name()='capturedEvents']" mode="body">
    <xsl:value-of select="@var"/> = <xsl:value-of select="@obj"/>.capturedEvents;
</xsl:template>

<xsl:template match="*[local-name()='bubbledEvents']" mode="body">
    <xsl:value-of select="@var"/> = <xsl:value-of select="@obj"/>.bubbledEvents;
</xsl:template>


<xsl:template match="*[local-name()='allEvents']" mode="body">
    <xsl:value-of select="@var"/> = <xsl:value-of select="@obj"/>.allEvents;
</xsl:template>

<xsl:template match="*[local-name()='allNotifications']" mode="body">
    <xsl:value-of select="@var"/> = <xsl:value-of select="@obj"/>.allNotifications;
</xsl:template>

<xsl:template match="*[local-name()='operation']" mode="body">
    <xsl:value-of select="@var"/> = <xsl:value-of select="@obj"/>.operation;
</xsl:template>

<xsl:template match="*[local-name()='key']" mode="body">
    <xsl:value-of select="@var"/> = <xsl:value-of select="@obj"/>.key;
</xsl:template>

<xsl:template match="*[local-name()='src' and @interface='UserDataNotification']" mode="body">
    <xsl:value-of select="@var"/> = <xsl:value-of select="@obj"/>.src;
</xsl:template>

<xsl:template match="*[local-name()='dst']" mode="body">
    <xsl:value-of select="@var"/> = <xsl:value-of select="@obj"/>.dst;
</xsl:template>

<xsl:template match="*[local-name()='allErrors']" mode="body">
    <xsl:value-of select="@var"/> = <xsl:value-of select="@obj"/>.allErrors;
</xsl:template>

<xsl:template match="*[local-name()='assertLowerSeverity']" mode="body">
    <xsl:value-of select="@obj"/>
    <xsl:text>.assertLowerSeverity("</xsl:text>
    <xsl:value-of select="@id"/>
    <xsl:choose>
    	<xsl:when test="@severity = 'SEVERITY_WARNING'">", 1</xsl:when>
    	<xsl:when test="@severity = 'SEVERITY_FATAL_ERROR'">", 3</xsl:when>
    	<xsl:otherwise>", 2</xsl:otherwise>
    </xsl:choose>
    <xsl:text>);
     </xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='data' and @interface='UserDataNotification']" mode="body">
    <xsl:param name="vardefs"/>
    <xsl:value-of select="@var"/>
    <xsl:text> = </xsl:text>
    <xsl:value-of select="@obj"/>.data;
</xsl:template>


<xsl:template name="produce-type">
	<xsl:param name="type"/>
    <xsl:text>var</xsl:text>
</xsl:template>

<xsl:template match="@type">
	<xsl:call-template name="produce-type">
		<xsl:with-param name="type" select="."/>
	</xsl:call-template>
</xsl:template>

<!--  this builds an override for the handleEvent method of EventListener  -->
<xsl:template match="*[local-name()='handleEvent']" mode="anonInner">
function handleEvent(listener, event, userObj) {
<xsl:apply-templates mode="body"/>
}
</xsl:template>

<xsl:template match="*[local-name()='load' and not(@interface)]" mode="body">
        <xsl:text>
      var </xsl:text><xsl:value-of select="@var"/><xsl:text>Ref = null;
      if (typeof(this.</xsl:text><xsl:value-of select="@var"/><xsl:text>) != 'undefined') {
        </xsl:text>
        <xsl:value-of select="@var"/><xsl:text>Ref = this.</xsl:text><xsl:value-of select="@var"/><xsl:text>;
      }
      </xsl:text>
	<xsl:value-of select="@var"/>
	<xsl:text> = load(</xsl:text>
    <xsl:value-of select="@var"/>
    <xsl:text>Ref, "</xsl:text>
    <xsl:value-of select="@var"/>
    <xsl:text>", "</xsl:text>
	<xsl:value-of select="@href"/>
	<xsl:text>");
      </xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='assertDOMException']" mode="body">
    <xsl:text>
	{
		success = false;
		try {
            </xsl:text>
	<xsl:apply-templates select="*/*" mode="body"/>
    <xsl:text>  }
		catch(ex) {
      success = (typeof(ex.code) != 'undefined' &amp;&amp; ex.code == </xsl:text>		            
    <xsl:variable name="excode" select="local-name(*)"/>
	<xsl:value-of select="$domspec/library/group/constant[@name = $excode]/@value"/>
	<xsl:text>);
		}
		assertTrue("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",success);
	}
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='assertEventException']" mode="body">
    <xsl:text>
	{
		success = false;
		try {
            </xsl:text>
	<xsl:apply-templates select="*/*" mode="body"/>
    <xsl:text>  }
		catch(ex) {            
      success = (typeof(ex.code) != 'undefined' &amp;&amp; ex.code == </xsl:text>		            
    <xsl:variable name="excode" select="local-name(*)"/>
	<xsl:value-of select="$domspec/library/group/constant[@name = $excode]/@value"/>
	<xsl:text>);
		}
		assertTrue("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",success);
	}
</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='assertLSException']" mode="body">
    <xsl:text>
	{
		success = false;
		try {
            </xsl:text>
	<xsl:apply-templates select="*/*" mode="body"/>
    <xsl:text>  }
		catch(ex) {            
      success = (typeof(ex.code) != 'undefined' &amp;&amp; ex.code == </xsl:text>		            
    <xsl:variable name="excode" select="local-name(*)"/>
	<xsl:value-of select="$domspec/library/group/constant[@name = $excode]/@value"/>
	<xsl:text>);
		}
		assertTrue("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",success);
	}
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='assertXPathException']" mode="body">
    <xsl:text>
	{
		success = false;
		try {
            </xsl:text>
	<xsl:apply-templates select="*/*" mode="body"/>
    <xsl:text>  }
		catch(ex) {            
      success = (typeof(ex.code) != 'undefined' &amp;&amp; ex.code == </xsl:text>		            
    <xsl:variable name="excode" select="local-name(*)"/>
	<xsl:value-of select="$domspec/library/group/constant[@name = $excode]/@value"/>
	<xsl:text>);
		}
		assertTrue("</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>",success);
	}
</xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='createTempURI']" mode="body">
    <xsl:value-of select="@var"/>
    <xsl:text> = createTempURI("</xsl:text>
    <xsl:choose>
    	<xsl:when test="@scheme">
    		<xsl:value-of select="@scheme"/>
    	</xsl:when>
    	<xsl:otherwise>
    		<xsl:text>file</xsl:text>
    	</xsl:otherwise>
    </xsl:choose>
    <xsl:text>");
      </xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='assertImplementationException']" mode="body">
    <xsl:param name="vardefs"/>
      {
         success = false;
         try {
            <xsl:apply-templates mode="body"/>
            <xsl:text>
      } catch (ex) {
    	 success = true;
      }
      assertTrue("</xsl:text>
      <xsl:value-of select="@id"/><xsl:text>", success);
	}
      </xsl:text>
</xsl:template>


<xsl:template match="text()" mode="body"/>

<xsl:template match="*" mode="body">
	<xsl:variable name="feature" select="local-name(.)"/>
    <xsl:variable name="interface" select="@interface"/>
	<xsl:variable name="method" select="$domspec/library/interface[not($interface) or @name=$interface]/method[@name = $feature]"/>
	<xsl:choose>
		<xsl:when test="$method">
			<xsl:call-template name="produce-method">                                  
				<xsl:with-param name="method" select="$method"/>
			</xsl:call-template>
		</xsl:when>
		<xsl:otherwise>
			<xsl:variable name="attribute" select="$domspec/library/interface[not($interface) or @name = $interface]/attribute[@name = $feature]"/>
			<xsl:choose>
				<xsl:when test="$attribute">
					<xsl:call-template name="produce-attribute"/>
				</xsl:when>

				<xsl:otherwise>
					<xsl:message>Unrecognized element <xsl:value-of select="local-name(.)"/></xsl:message>
					<xsl:text>fail("Unrecognized method or attribute </xsl:text><xsl:value-of select="local-name(.)"/><xsl:text>");
</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
      </xsl:text>
</xsl:template>

<xsl:template name="cast">
	<xsl:param name="var"/>
	<xsl:param name="vartype"/>
	<xsl:param name="reqtype"/>
</xsl:template>


<xsl:template name="retval-cast">
	<xsl:param name="vartype"/>
	<xsl:param name="rettype"/>
	<xsl:param name="variable"/>
</xsl:template>


<xsl:template name="build-accessor">
	<xsl:param name="prefix"/>
	<xsl:param name="attribute"/>
	<xsl:value-of select="$attribute"/>
</xsl:template>

<xsl:template name="produce-param">
	<xsl:param name="value"/>
    <xsl:value-of select="$value"/>
</xsl:template>

<xsl:template name="produce-specific-attribute">
	<xsl:param name="attribute"/>
	<xsl:variable name="obj" select="@obj"/>
	<xsl:if test="@value">
        <xsl:value-of select="$obj"/>
        <xsl:text>.</xsl:text>
        <xsl:value-of select="$attribute/@name"/>
		<xsl:text> = </xsl:text>
        <xsl:value-of select="@value"/>
        <xsl:text>;
</xsl:text>
    </xsl:if>
	<xsl:if test="@var">
		<xsl:value-of select="@var"/>
		<xsl:variable name="var" select="@var"/>
		<xsl:text> = </xsl:text>
        <xsl:value-of select="@obj"/>
        <xsl:text>.</xsl:text>
        <xsl:value-of select="$attribute/@name"/>
        <xsl:text>;
</xsl:text>
    </xsl:if>
</xsl:template>


<xsl:template name="produce-specific-method">
	<xsl:param name="method"/>
	<xsl:variable name="current" select="."/>
	<xsl:variable name="obj" select="@obj"/>
	<xsl:variable name="var" select="@var"/>
	<xsl:if test="@var">
		<xsl:value-of select="@var"/>
		<xsl:text> = </xsl:text>
	</xsl:if>
    <xsl:value-of select="@obj"/>
	<xsl:text>.</xsl:text>
	<xsl:value-of select="$method/@name"/>
	<xsl:text>(</xsl:text>
	<xsl:for-each select="$method/parameters/param">
		<xsl:if test="position() &gt; 1">,</xsl:if>
		<xsl:value-of select="$current/@*[name() = current()/@name]"/>
	</xsl:for-each>
	<xsl:text>);</xsl:text>
</xsl:template>



<xsl:template name="produce-attribute">
	<xsl:variable name="attribName" select="local-name(.)"/>
	<xsl:choose>
		<!--  if interface is specified -->
		<xsl:when test="@interface">
			<xsl:variable name="interface" select="@interface"/>			
			<xsl:call-template name="produce-specific-attribute">
				<xsl:with-param name="attribute" select="$domspec/library/interface[@name = $interface]/attribute[@name = $attribName]"/>
			</xsl:call-template>
		</xsl:when>
		<xsl:otherwise>
			<xsl:call-template name="produce-specific-attribute">
				<xsl:with-param name="attribute" select="$domspec/library/interface/attribute[@name = $attribName]"/>
			</xsl:call-template>
		</xsl:otherwise>
	</xsl:choose>
	
</xsl:template>

<xsl:template name="produce-method">
	<xsl:variable name="methodName" select="local-name(.)"/>
	<xsl:choose>
		<!--  if interface is specified -->
		<xsl:when test="@interface">
			<xsl:variable name="interface" select="@interface"/>			
			<xsl:call-template name="produce-specific-method">
				<xsl:with-param name="method" select="$domspec/library/interface[@name = $interface]/method[@name = $methodName]"/>
			</xsl:call-template>
		</xsl:when>
		<xsl:otherwise>
			<xsl:variable name="methods" select="$domspec/library/interface/method[@name = $methodName]"/>
			<xsl:call-template name="produce-specific-method">
				<xsl:with-param name="method" select="$methods[1]"/>
			</xsl:call-template>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template match="*[local-name()='not']" mode="condition">
	!(<xsl:apply-templates mode="condition"/>)
</xsl:template>

<xsl:template match="*[local-name()='and']" mode="condition">
	(<xsl:apply-templates select="*[1]" mode="condition"/>
	<xsl:for-each select="*[position() &gt; 1]">
		<xsl:text> &amp;&amp; </xsl:text>
		<xsl:apply-templates select="." mode="condition"/>
	</xsl:for-each>)
</xsl:template>

<xsl:template match="*[local-name()='or']" mode="condition">
	(<xsl:apply-templates select="*[1]" mode="condition"/>
	<xsl:for-each select="*[position() &gt; 1]">
		<xsl:text> || </xsl:text>
		<xsl:apply-templates select="." mode="condition"/>
	</xsl:for-each>)
</xsl:template>

<xsl:template match="*[local-name()='xor']" mode="condition">
	(<xsl:apply-templates select="*[1]" mode="condition"/>
	<xsl:for-each select="*[position() &gt; 1]">
		<xsl:text> ^ </xsl:text>
		<xsl:apply-templates select="." mode="condition"/>
	</xsl:for-each>)
</xsl:template>


<xsl:template match="*[local-name()='isTrue']" mode="condition">
	<xsl:value-of select="@value"/>
</xsl:template>

<xsl:template match="*[local-name()='isFalse']" mode="condition">
	!<xsl:value-of select="@value"/>
</xsl:template>

<xsl:template match="*[local-name()='same']" mode="condition">
	same(<xsl:value-of select="@expected"/>,<xsl:value-of select="@actual"/>)
</xsl:template>


<xsl:template match="*[local-name()='equals']" mode="condition">
	<xsl:call-template name="equalsCondition"/>
</xsl:template>

<xsl:template name="equalsCondition">
	<xsl:choose>
		<xsl:when test="@ignoreCase='auto'">
			<xsl:text>equalsAutoCase("</xsl:text>
			<xsl:choose>
				<xsl:when test="@context">
					<xsl:value-of select="@context"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>element</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>", </xsl:text>
			<xsl:value-of select="@expected"/>
			<xsl:text>, </xsl:text>
			<xsl:value-of select="@actual"/>
			<xsl:text>)</xsl:text>
		</xsl:when>
		<xsl:otherwise>
    		<xsl:text>(</xsl:text>
    		<xsl:value-of select="@expected"/>
			<xsl:choose>
				<xsl:when test="@ignoreCase='true'">
					<xsl:text>.toUpperCase() == </xsl:text>
				</xsl:when>
				<xsl:when test="@bitmask">
					<xsl:text> &amp; </xsl:text><xsl:value-of select="@bitmask"/><xsl:text> == </xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text> == </xsl:text>
				</xsl:otherwise>
			</xsl:choose>
    		<xsl:value-of select="@actual"/>
			<xsl:choose>
				<xsl:when test="@ignoreCase='true'">
					<xsl:text>.toUpperCase())</xsl:text>
				</xsl:when>
				<xsl:when test="@bitmask">
					<xsl:text> &amp; </xsl:text><xsl:value-of select="@bitmask"/><xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>)</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template match="*[local-name()='notEquals']" mode="condition">
	<xsl:text>!</xsl:text>
	<xsl:call-template name="equalsCondition"/>
</xsl:template>


<xsl:template match="*[local-name()='less']" mode="condition">
	(<xsl:value-of select="@actual"/> &lt; <xsl:value-of select="@expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='lessOrEquals']" mode="condition">
	(<xsl:value-of select="@actual"/> &lt;= <xsl:value-of select="@expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='greater']" mode="condition">
	(<xsl:value-of select="@actual"/> &gt; <xsl:value-of select="@expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='greaterOrEquals']" mode="condition">
	(<xsl:value-of select="@actual"/> &gt;= <xsl:value-of select="@expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='isNull']" mode="condition">
	(<xsl:value-of select="@obj"/> == null)
</xsl:template>


<xsl:template match="*[local-name()='notNull']" mode="condition">
	(<xsl:value-of select="@obj"/> != null)
</xsl:template>

<xsl:template match="*[local-name()='instanceOf']" mode="condition">
	(<xsl:value-of select="@obj"/> instanceOf <xsl:value-of select="@type"/>)
</xsl:template>


<xsl:template match="*[local-name()='hasSize']" mode="condition">
	(<xsl:value-of select="@obj"/>.length == <xsl:value-of select="@expected"/>)
</xsl:template>

<xsl:template match="*[local-name()='contentType']" mode="condition">
	(builder.contentType == "<xsl:value-of select="@type"/>")
</xsl:template>

<xsl:template match="*[local-name()='contains' and @interface='DOMString']" mode="condition">
    <xsl:text>(</xsl:text><xsl:value-of select="@obj"/>.indexOf(<xsl:value-of select="@str"/><xsl:text>) >= 0)</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='implementationAttribute']" mode="condition">
	<xsl:text>(getImplementationAttribute("</xsl:text>
	<xsl:value-of select="@name"/>
    <xsl:text>") == </xsl:text>
    <xsl:value-of select="@value"/>
    <xsl:text>)</xsl:text>
</xsl:template>



<xsl:template match="*[local-name()='hasFeature']" mode="condition">
	<xsl:if test="@obj">
		<xsl:value-of select="@obj"/>
		<xsl:text>.</xsl:text>
	</xsl:if>
	<xsl:text>hasFeature(</xsl:text>
	<xsl:value-of select="@feature"/>,
	<xsl:choose>
		<xsl:when test="@version">
			<xsl:value-of select="@version"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>""</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>)</xsl:text>
</xsl:template>


<xsl:template match="*[local-name()='try']" mode="body">
    <xsl:param name="vardefs"/>
    <xsl:variable name="exceptions" select="$domspec//exception[@id]"/>
    <xsl:variable name="catches" select="*[local-name() = 'catch']/*"/>
    <xsl:variable name="implException" select="$catches[local-name() = 'ImplementationException']"/>
    
    <xsl:text>
      try {
      </xsl:text>
      <xsl:apply-templates select="*[local-name() != 'catch']" mode="body">
      	<xsl:with-param name="vardefs" select="$vardefs"/>
      </xsl:apply-templates>
      <xsl:text>
      } catch (ex) {
		  if (typeof(ex.code) != 'undefined') {      
       </xsl:text>
      <xsl:if test="*[local-name() = 'catch']/*[local-name() != 'ImplementationException']">
      	   <xsl:text>switch(ex.code) {
       </xsl:text>
      	   <xsl:for-each select="*[local-name() = 'catch']/*[local-name() != 'ImplementationException']">
      	   		<xsl:text>case </xsl:text>
      	   		<xsl:variable name="catchCode" select="@code"/>
      	   		<xsl:text>/* </xsl:text><xsl:value-of select="$catchCode"/><xsl:text> */ </xsl:text>
      	   		<xsl:for-each select="$exceptions">
      				<xsl:value-of select="following-sibling::group[1]/constant[@name = $catchCode]/@value"/>
      	   		</xsl:for-each>
      	   		<xsl:text> :
       </xsl:text> 
      			<xsl:apply-templates select="*" mode="body">
      				 <xsl:with-param name="vardefs" select="$vardefs"/>
      			</xsl:apply-templates>
				<!--  if there are no children, add a break -->
      			<xsl:if test="count(*) = 0">
      				 <xsl:text>break;
      </xsl:text>
      			</xsl:if>
      			<!--  if the last child is not a return, add a break  -->
      			<xsl:for-each select="*">
      				 <xsl:if test="not(following-sibling::*) and local-name() != 'return'">
      					 <xsl:text>break;
      </xsl:text>
      				 </xsl:if>
      			</xsl:for-each>
      		</xsl:for-each>
      			<xsl:text>    default:
          throw ex;
          }
       </xsl:text>  
      </xsl:if>
      <xsl:text>} else { 
       </xsl:text>
      <xsl:choose>
          <!--  if there is an ImplementationException clause,
                     fill in any of its statements    -->
      	  <xsl:when test="*[local-name() = 'catch']/*[local-name() = 'ImplementationException']">
       		<xsl:apply-templates select="*[local-name() = 'catch']/*[local-name() = 'ImplementationException']/*" mode="body">
      			<xsl:with-param name="vardefs" select="$vardefs"/>
       		</xsl:apply-templates>
           </xsl:when>
           
           <xsl:otherwise>
           		<xsl:text>throw ex;
        </xsl:text>
           </xsl:otherwise>
       </xsl:choose>
       <xsl:text>}
         }
        </xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='getResourceURI']" mode="body">
    <xsl:value-of select="@var"/>
    <xsl:text> = getResourceURI(</xsl:text>
    <xsl:value-of select="@href"/>
    <xsl:text>, "</xsl:text>
    <xsl:choose>
    	<xsl:when test="@scheme">
    		<xsl:value-of select="@scheme"/>
    	</xsl:when>
    	<xsl:otherwise>
    		<xsl:text>file</xsl:text>
    	</xsl:otherwise>
    </xsl:choose>
    <xsl:text>", </xsl:text>
    <xsl:choose>
    	<xsl:when test="@contentType">
    		<xsl:text>"</xsl:text>
    		<xsl:value-of select="@contentType"/>
    		<xsl:text>"</xsl:text>
    	</xsl:when>
    	<xsl:otherwise>
    		<xsl:text>builder.contentType</xsl:text>
    	</xsl:otherwise>
    </xsl:choose>
    <xsl:text>);
      </xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='createTempFileURI']" mode="body">
    <xsl:value-of select="@var"/>
    <xsl:text> = createTempFileURI();
      </xsl:text>
</xsl:template>

<xsl:template match="*[local-name()='createTempHttpURI']" mode="body">
    <xsl:value-of select="@var"/>
    <xsl:text> = createTempHttpURI();
      </xsl:text>
</xsl:template>


<xsl:template match="*[local-name() = 'var']" mode="innerClass">
   <xsl:param name="vardefs"/>
   <xsl:text>
     /**
      *    Inner class implementation for variable </xsl:text>
   <xsl:value-of select="@name"/>
   <xsl:text> 
      */
var </xsl:text>
	<xsl:value-of select="@name"/>
	<xsl:text>;

/**
        * Constructor
</xsl:text>
       <!--  write @param comments for each parameter   -->
       <xsl:variable name='classFields' select="*[local-name() = 'var']"/>
        <xsl:for-each select="*[local-name() = 'var'  and @value]">
        <xsl:text>
        * @param </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text> Value from value attribute of nested var element</xsl:text>
   </xsl:for-each>
   <xsl:text>
        */
	      
function </xsl:text>
   <xsl:variable name="className" select="concat(@type, generate-id(.))"/>
   <xsl:variable name="instanceVar" select="@name"/>
   <xsl:value-of select="concat($className, '(')"/>
   <xsl:for-each select="*[local-name() = 'var' and @value]">
   		<xsl:if test="position() &gt; 1">
        	<xsl:text>, </xsl:text>
        </xsl:if>
        <xsl:value-of select="@name"/>
   </xsl:for-each>
   <xsl:text>) { 
           </xsl:text>
   <xsl:for-each select="*[local-name() = 'var' and @value]">
        <xsl:text>this.</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text> = </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>;
           </xsl:text>
   </xsl:for-each>
   <xsl:text>}
   </xsl:text>
   <xsl:variable name="interface-name" select="@type"/>
   <xsl:variable name="interface" select="$domspec/library/interface[@name=$interface-name]"/>
   <xsl:for-each select="*[local-name() != 'var']">
        <xsl:call-template name="produce-inner-feature">
            <xsl:with-param name="method-name" select="local-name()"/>
            <xsl:with-param name="interface" select="$interface"/>
            <xsl:with-param name="vardefs" select="$vardefs"/>
            <xsl:with-param name="className" select="$className"/>
            <xsl:with-param name="instanceVar" select="$instanceVar"/>
            <xsl:with-param name="classFields" select="$classFields"/>
        </xsl:call-template>
   </xsl:for-each>
</xsl:template>


<xsl:template name="produce-inner-feature">
    <xsl:param name="interface"/>
    <xsl:param name="method-name"/>
    <xsl:param name="vardefs"/>
    <xsl:param name="className"/>
    <xsl:param name="instanceVar"/>
    <xsl:param name="classFields"/>

    <xsl:variable name="method-def" select="$interface/method[@name=$method-name]"/>
        <xsl:choose>
            <xsl:when test="$method-def">
                <xsl:text>
        /**
         *    </xsl:text><xsl:value-of select="$method-def/descr"/>
         <xsl:for-each select="$method-def/parameters/param">
            <xsl:text>
         * @param </xsl:text><xsl:value-of select="@name"/><xsl:text> </xsl:text><xsl:value-of select="descr"/>
         </xsl:for-each>
         <xsl:text>
         */
</xsl:text>
		 <xsl:value-of select="$className"/>
		 <xsl:text>.prototype.</xsl:text>
         <xsl:value-of select="$method-def/@name"/>
         <xsl:text> = function(</xsl:text>
         <xsl:for-each select="$method-def/parameters/param">
              <xsl:if test="position() &gt; 1">
                   <xsl:text>, </xsl:text>
              </xsl:if>
              <xsl:value-of select="@name"/>
         </xsl:for-each>
         <xsl:text>) {
         //
         //   bring class variables into function scope
         //
        </xsl:text>
   <xsl:for-each select="$classFields">
        <xsl:text>var </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text> = </xsl:text>
        <xsl:value-of select="concat($instanceVar, '.')"/>
        <xsl:value-of select="@name"/>
        <xsl:text>;
           </xsl:text>
   </xsl:for-each>

        <xsl:apply-templates mode="body">
                    <xsl:with-param name="vardefs" select="*[local-name() = 'var'] | $method-def/parameters/param | preceding-sibling::*[local-name() = 'var']"/>
        </xsl:apply-templates>
                <xsl:text>}
</xsl:text>
            </xsl:when>

            <!--  not method, possibly an attribute   -->
            <xsl:when test="$interface/attribute[@name = $method-name]">
<xsl:value-of select="$className"/>.prototype.<xsl:value-of select="$method-name"/> = <xsl:value-of select="*[local-name() = 'get']/*[local-name() = 'return']/@value"/><xsl:text>;
</xsl:text>            
            </xsl:when>

            <xsl:when test="$interface/@inherits">
                <xsl:call-template name="produce-inner-feature">
                    <xsl:with-param name="interface" select="$domspec/library/interface[@name=$interface/@inherits]"/>
                    <xsl:with-param name="method-name" select="$method-name"/>
    				<xsl:with-param name="className" select="$className"/>
    				<xsl:with-param name="instanceVar" select="$className"/>
    				<xsl:with-param name="classFields" select="$classFields"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:otherwise>
                <xsl:message terminate="yes">Method <xsl:value-of select="$method-name"/> not found for interface <xsl:value-of select="$interface/@name"/>.</xsl:message>
            </xsl:otherwise>
        </xsl:choose>
</xsl:template>


</xsl:stylesheet>
